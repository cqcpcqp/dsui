import { Fiber, Hook } from './model';
import { reconcileChildren } from './reconcile';
import { getRenderContextByFiber, contextQueue } from './context';

/**
 * Because useState will be called in updateFunctionComponent, this variable needs
 * to be defined here to save the fiber currently being processed
 */
// TODO(cqcpcqp) 这里叫wipFiber感觉不合适，要跟performUnitOfWork的命名做出区分
let wipFiber: Fiber;

/**
 * Each useState corresponds to a hook. A fiber corresponds to multiple useState hooks
 * hence the hookIndex (Like wipFiber mentioned earlier, this is a shared variable that exists
 * across updateFunctionComponent and useState)
 * This implicitly establishes a logical dependency:
 * when updateFunctionComponent is called, it will invoke useState
 */
let hookIndex: number;

/**
 * A function component's Fiber does not have its own DOM node.
 * Instead, it appends the children generated by the function component under the parent Fiber.
 */
export function updateFunctionComponent(fiber: Fiber) {
  if (typeof fiber.type !== 'function') {
    throw new Error('Function component fiber type must be a function');
  }

  wipFiber = fiber;
  hookIndex = 0;
  wipFiber.hooks = [];
  const children = [fiber.type(fiber.props)];
  reconcileChildren(fiber, children);
}

/**
 * 1. A: updateFunctionComponent wipFiber Change to 1
 * 2. A: useState fiber 1
 * 3. B: updateFunctionComponent wipFiber Change to 2
 * 4. B: useState fiber 2
 * 5. A: setState fiber 1
 * 5. B: setState fiber 2
 */
export function useState(initial) {
  const oldHook: Hook = wipFiber.alternate?.hooks && wipFiber.alternate.hooks[hookIndex];
  const hook = {
    // State Persistence: Preserving state during re-renders through ​​oldHook.state​​ to prevent loss.
    state: oldHook ? oldHook.state : initial,
    queue: [],
  };

  // Store current wipFiber for setState
  const useStateFiber = wipFiber;

  // Handling Pending Updates: Retrieving accumulated but unprocessed state
  // updates from the previous rendering cycle via ​​oldHook.queue​​.
  const actions = oldHook?.queue || [];
  actions.forEach((action: Function) => {
    hook.state = action(hook.state);
  });

  const setState = (action) => {
    hook.queue.push(action);

    const { currentRoot, deletions } = getRenderContextByFiber(useStateFiber);
    const renderContext = getRenderContextByFiber(useStateFiber);

    renderContext.wipRoot = {
      dom: currentRoot.dom,
      props: currentRoot.props,
      alternate: currentRoot,
    };
    deletions.length = 0;
    contextQueue.push(renderContext.wipRoot);
  };

  wipFiber.hooks.push(hook);
  hookIndex++;

  return [hook.state, setState];
}
